%
% do not add anything in this part
%
\documentclass[catalog.tex]{subfiles}

% bib file: write the bibliography in a file having the same name as the latex file
% change the suffix".tex" by ".bib" 
% biblatex is required, do not use bibtex!
% DO NOT TOUCH THE FOLLOWING LINE

\begin{document}

%
% things can be added below
%

\def\pbname{A* Search} %change this, do not use any number, just the name

\section{\pbname} 

% only for overview, so short description (no more than 1-2 lines)
\begin{overview}
\item [Algorithm:] A* Search~(algo.~\ref{alg:\currfilebase}) 
	% -	must match the label of the algorithm 
	% - when writing more than one algo use alg:\currfilebase_a, alg:\currfilebase_b, etc.
\item [Input:] A graph $G=\langle V,E\rangle$, starting point $S$ and goal $G$
\item [Complexity:] $O(b^d)$, where $d$ is the depth of solution and $b$ is branching factor
\item [Data structure compatibility:] priority queue, graph
\item [Common applications:] search optimization, game development
\end{overview}


\begin{problem}{\pbname}
	A* (or A-star) is a classic graph-tranversal and path finding algorithm. It is proposed by Peter Hart, Nils Nilsson and Bertram Raphael from Stanford Research Institute in 1986 \cite{hart1968formal}. It is an extension on the previous Dijkstra's algorithm. Introducing of concept of heuristic functions, A* is complete and optimal as well as optimally efficient \cite{russell_artificial_2010}, on the contrary to its ancestor. This makes it still one of the prior choices in many application cases. 
\end{problem}


\subsection*{Description}

One of the complete and optimal algorithm is the uniform-cost search (UCS), originating from Dijkstra \cite{russell_artificial_2010}, where in each iteration the nodes which would add least cost would be chosen, i.e. the node closest to the current one. UCS expands the nodes evenly in all directions, making it slow and space-costly. 

An naive heuristic search, greedy best-first algorithm, always chooses the nodes which seems closest to the goal. These distances are made by estimation, which can give us a genaral direction of searching and greatly save run-time in some cases. However, since the heuristics values are estimated, what solution the algorithm would return dependent on the choice of heuristic functions. This means that this scheme is neither complete nor optimal. What's more, the quality of heuristic function also affects the degree of complexity reduction.

The A* algorithm is the combination of the above two algorithm. As can be see in the pseudocode below\ref{alg:problem-97}. Denote the cost from starting point $S$ to node $n$ to be $g(n)$ and the heuristic to be $h(n)$, what A* algorithm pays attention to is their sum $f(n)=g(n)+h(n)$. In each iteration, the nodes with smallest $f(n)$ would be seleted and expanded on. The algorithm terminates when the goal is reached.

To run A*, we need to initialize two sets $open$ and $closed$, where stores the nodes to be expanded and having been expanded. What means by "expanding" a node is to visit its neighbours and let them wait to be expanded. Firstly, add the starting point to $open$. We would always selete and remove a node $n$ from $open$ with the smallest $f(n)$ so as to expand it and add to $closed$. Then we calculate the cost of the neighbours of $n$ and add them to $open$. The algorithm continues until we the node wo remove from $open$ is exactly the goal. If goal is not returned even if $open$ is empty, we can be sure there is no such a path. 

There are two points to be made here. Firstly, since we always need to selete the node from $open$ with the smallest $f$, we are actually applying a priority queue here, whose priority is just the value of $f$. Another point is that although A* algorithm can reach the goal by travalling along the shortest path, it can return directly return it. \textbf{Backtracking} is necessary to record and generate the path. One of the simple way is to attach the nodes with their predecessors when pushing them into the $open$ set. 

It should be clarified that to guarantee the optimality, the quality of heuristic function matters. The first requirement is \textbf{admissible} heuristic, which implies that the heuristic never over-estimates the potential costs. Another property to ensure optimality is consistency. A heuristic is consistent if for every node and each of its successor $n^\prime$ generated by action $a$, there is a triangle inequality
$$
h(n) - h(n^\prime) \leq cost(n, n^\prime).
$$
That is to say, the difference of heuristic for two neighbouring nodes should never be larger than the true cost to travel between them. 

It is sufficient to show that consistency is a stricter requirement than admissibiliy, and being consistent suffices to be admissible. Implementation of A* is easy and able to be reused, but the establishment of a good (consistent) heuristic for the application case is what important and hard job to do.

A* can find the shortest path on a graph for given starting point and goal, therefore it can be applied to all the mathematical or engineering problems that can be transferred in a graph search problem, such as navigation through a maze, routing communication traffics and integerted circuit design. A* itself is invented in the project \textit{Shakey the robot} as the way of path searching \cite{shakey}. In modern time, one of the major field using A* is game development. As the most popular path-finding algorithm nowadays \cite{cui2011based}, A* is what help most of the AI players find their way or decide their action.

% \begin{table}[!htb]
% 	\caption{My table}
% 	\label{tbl:\currfilebase}
% 	\centering
% 	\begin{tabular}{lll}
% 		\toprule
% 		c1 & c2 & c3 \\
% 		\midrule
% 		1 & 2 & 3 \\
% 		4 & 5 & 6 \\
% 		\bottomrule
% 	\end{tabular}
% \end{table}

% add comment in the pseudocode: \cmt{comment}
% define a function name: \SetKwFunction{shortname}{Name of the function}
% use the defined function: \shortname{$variables$}
% use the keyword ``function'': \Fn{function name}, e.g. \Fn{\shortname{$var$}}

\begin{Algorithm}[A* Search\label{alg:\currfilebase}]
	% -	must match the reference in the overview
	% - when writing more than one algo use alg:\currfilebase_a, alg:\currfilebase_b, etc.
	%\SetKwFunction{myfunction}{MyFunction}	
	\Input{A graph $G=\langle V,E\rangle$, starting point $S$ and goal $G$}
	\Output{the shortest path from $S$ to $G$ if exists}
	%	\Fn{\myfunction{$a,b$}}{
    %	}
    $closed \gets \{\}$ 

    $open \gets$ priority queue with $f$ as priority

    set $S.g=0$
    
    $Push(open, S)$ with $S.f=0+h(S)$

    \While{$open$ is not empty}
    {
        $node \gets$ $remove\_front(open)$

        \If{$node==G$}
        {
            \Ret 
        }

        \If{$node$ not in $closed$}
        {
            add $node$ to $closed$

            \For{$n$ in $Adjcent(node)$}
            {
                $n.g = node.g + Distance(node, n)$

                $Push(open, n)$ with $n.f=n.g+h(n)$
            }
        }
        
    }

	\BlankLine

	\Ret Failure

\end{Algorithm}


% include references where to find information on the given problem using latex bibliography
% insert references in the text (\cite{}) and write bibliography file in problem-nb.bib (replace nb with the problem number)
% prefer books, research articles, or internet sources that are likely to remain available over time
% as much as possible offer several options, including at least one which provide a detailed study of the problem
% if available include links to programs/code solving the problem
% wikipedia is NOT acceptable as a unique reference
\singlespacing
\printbibliography[title={References.},resetnumbers=true,heading=subbibliography]

\end{document}
